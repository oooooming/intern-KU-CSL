# 프로그래머가 몰랐던 멀티코어 CPU 이야기 Chap2

Chap2. 프로세서의 언어: 명령어 집합 구조

## ISA

: Instruction Set Architecture(명령어 집합 구조), 프로그래머와 프로세서가 직접적으로 소통할 수 있는 언어.

- 프로세서를 설계할 때 첫 번째로 하는 것이 ISA를 정의하는 것.

- 프로그래밍 방법론과 프로세서 구현의 많은 부분을 결정함.

  - 명령어 종류, 피연산자 타입, 레지스터 개수, 인코딩 방법 등.

- ISA가 다른 프로세서면 프로그램이 제대로 작동할 수 없기 때문에 이런 문제를 해결하고자 등장한 것이 선(Sun)의 자바 가상머신(JVM)이나 마이크로소프트의 .NET 프레임워크임. 가상적인 프로세서 언어로 프로그램을 기술하여 특정 프로세서 혹은 운영체제와 독립적으로 프로그램이 작동할 수 있도록 함.

- 컴파일러나 인터프리터를 통해 함수형 언어가 원시적인 명령어의 흐름으로 변환.

  1. 기본적인 사칙 연산과 논리 연산
 
  2. 메모리에 쓰고, 읽는 명령
 
  3. 프로그램의 실행 흐름을 제어하는 분기 및 호출 명형
 
- ISA 위에 존재하는 ABI(Application Binary Interface) 응용프로그램과 운영체제 사이의 함수호출규약, 바이너리 포멧에 대한 규약 등을 통해 실제 프로그램이 돌아감.

## RISC vs. CISC

### CISC 

- 등장배경: 당시 컴파일러의 성능이 좋지 않아 프로그래밍 언어와 1:1대응 될 정도로 많은 명령어가 필요했으며 메모리가 매우 비싸 짧으면서도 많은 의미를 함축하는 명령어가 필요했음. 이런 이유로 최초의 ISA는 복잡한 형태의 CISC의 형태를 가짐.

- 명령어의 길이가 가변적이며 여러 복잡한 형태의 주소 모드의 지원을 받을 수 있고 범용 레지스터의 개수가 비교적 작음.

- ex) 인텔의 x86, DEC의 VAX 명령어 구조

### RISC 

- 등장배경: 실제 사용되는 명령어 종류가 그렇게 많지 않음을 밝혀내었고 CISC가 너무 과도하게 설계하는 점에서 문제점을 발견하여 프로세서 구조의 단순함과 고속화를 위해 명령어 길이를 4바이트로 제한해도 괜찮다는 결론에 다다름.

- 간단한 명령어 덕에 회로가 단순해져서 저렴한 비용으로 제조할 수 있어졌으나 컴파일러의 할 일이 늘어남. 하드웨어의 복잡함을 덜어 절약한 트랜지스터 수를 성능향상에 사용하여 범용 레지스터의 개수가 비교적 많음.

- ex) ARM과 IBM의 PowerPC, MIPS

### CISC와 RICS의 차이

프로그램을 빠르게 실행해야한다는 목적은 같지만 하드웨어와 소프트웨어에 어떻게 일을 분담하고, 또 어떻게 소통하느냐는 문제를 RISC와 CISC가 다르게 접근함.

- 레지스터 개수가 더 많고 하드웨어 구현이 간단해 파이프라인 구현과 고성능 컴퓨팅에 CISC보다 RISC가 더 적합하다고 알려졌으나 최근들어서는 이런 단순한 비교가 성립되지 않음.

- CISC 명령어를 내부 마이크로 명령어, 마이크로 옵으로 쪼개어 처리하여 내부적으로 RISC과 비슷하게 동작하여 RISC의 장점을 차용함. 또한 레지스터 리네이밍 테크닉으로 100개 이상의 물리적인 레지스터가 활용되므로 도식적인 RISC와 CISC의 비교가 무용함.

-  
